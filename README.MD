For @Async and CompletableFuture, check --> Appointment-service main class, AsyncConfig class, AppointmentDomainService class, and ExternalServiceClient class.
For @UniqueConstraint and Optimistic Locking, check --> AvailabilitySlot entity class: @Version used for Optimistic Locking, AvailabilityService class --> check blockSlots() method for Optimistic lock exception.

---

# Spring Boot Asynchronous Processing & Optimistic Locking

---

## ğŸ§© 1ï¸âƒ£ What is `@Async` in Spring Boot?

The `@Async` annotation is used to execute a method asynchronously, i.e., in a separate thread.  
This means the caller wonâ€™t wait for the method to complete â€” ideal for tasks like:

- Sending emails or SMS
- Logging or audit operations
- Generating reports
- Long-running background processes

---

## ğŸ§  1ï¸âƒ£ What is `CompletableFuture`?

`CompletableFuture` is a Java concurrency class (from `java.util.concurrent`) used to handle asynchronous results â€” i.e., results that will be available in the future after a background task finishes.

Think of it like a â€œpromiseâ€ that says:

> â€œIâ€™m doing this work in another thread. When Iâ€™m done, Iâ€™ll give you the result.â€

---

## âš™ï¸ 2ï¸âƒ£ Why Use `CompletableFuture` with `@Async`

When you mark a method with `@Async`, Spring executes it in a separate thread and immediately returns control to the caller.

If that async method returns `void`, the caller has no way to:

- Get the result later
- Know when itâ€™s completed
- Handle exceptions

ğŸ‘‰ Thatâ€™s where `CompletableFuture` comes in.  
It lets you return a placeholder object that will eventually contain the actual result.

---

## ğŸ§¾ 5ï¸âƒ£ Summary Table

| Aspect | Explanation |
|--------|-------------|
| `@Async` | Executes the method in a new thread |
| `CompletableFuture<T>` | Represents a result that will be available later |
| `CompletableFuture.completedFuture(value)` | Immediately wraps a computed value (useful for returning an already-available result) |
| `.get()` | Waits for result (blocking) |
| `.join()` | Similar to `.get()`, but throws unchecked exceptions |
| `.allOf()` | Combines multiple futures and waits for all to complete |
| **Benefit** | Run multiple async tasks concurrently and combine results |

> `@Async` tells Spring:  
> â€œRun this method in a background thread, not the main thread.â€

The method starts executing asynchronously.  
`CompletableFuture` gives you an object that represents the future result of that background work.

---

## ğŸ§© What is Optimistic Locking?

Optimistic locking assumes that most of the time, no one else is modifying the same record.  
Instead of blocking access (like pessimistic locks), it just checks **before commit** whether the record was changed by someone else.

If it detects a concurrent modification â€” it throws an exception (`OptimisticLockException`) and you retry or fail gracefully.

---

## ğŸ§  How It Works

1. When you read an `AvailabilitySlot`, JPA remembers its version (e.g., 3).
2. When you update it (e.g., mark it blocked), Hibernate generates an SQL like:

```sql
UPDATE availability_slots
SET blocked = true, version = 4
WHERE id = 'slot123' AND version = 3;
```

---

## How Optimistic Locking Works

- If no other transaction modified the row â†’ one row is updated â†’ âœ… success  
- If another transaction already modified it (version now = 4) â†’  
  `WHERE id='slot123' AND version=3` fails â†’ 0 rows updated â†’  
  Hibernate throws `OptimisticLockException`

---

## âš™ï¸ Why `@UniqueConstraint` and `@Version` Work Fine Together

- `@UniqueConstraint` â†’ enforced by the database engine (MySQL, PostgreSQL, etc.)  
  Ensures certain column combinations are **unique across all rows**.  
  Example: No two slots with the same doctor, date, startTime, and endTime.

- `@Version` â†’ handled by JPA/Hibernate inside the transaction  
  Ensures that **two threads donâ€™t update the same row at the same time**

They operate at **different layers**, so they **donâ€™t conflict**.
